var tsFileStruct = require("ts-file-parser");
var fs = require('fs');
var format = require("string-template");

var inputArgs = process.argv.slice(2);

var inputFile = inputArgs[0];
var outputFile = inputArgs[1];

var decls = fs.readFileSync(inputFile).toString();
var jsonStructure = tsFileStruct.parseStruct(decls, {}, inputFile);

var did_template = `service : {
{did_methods}
}
`

var template = `
// *************************************
// THIS IS GENERATED BY THE ACTOR PARSER
// *************************************
import * as CALL from "./lib/call";
import * as API from "./lib/api";
import * as COUNTER from "./counter";

var actor: COUNTER.{actor_class_name};
{canister_init}
{canister_methods}
`

var canister_init_template = `
export function canister_init(): void {
    var text: string = "Hello DFINITY from AssemblyScript";
    API.print(text);
    actor = new COUNTER.{actor_class_name}(API.caller(), API.time());
}
`

var canister_method_template = `
export function {func_type}_{func_name}(): void {
    //recieve inputs
    {recieve}

    //call function
    {actor_call}

    //respond
    {response}
}
`

var actor_call_void_template = `actor.{func_name}({params});`

var actor_call_template = `let response = actor.{func_name}({params});`

//TODO: search for the first class that extends the Actor class
var actorClass = jsonStructure.classes[0];

var method_template = "";
var did_methods_template = "";

actorClass.methods.forEach(m => {

    var funcType = getFunctionType(m.text);

    if (funcType) {


        let recieve = m.arguments.length == 0 ?
            "CALL.receiveEmpty();" :
            "var decoder = CALL.receiveDecoder();";

        //Compute input types
        let inputArgs = [];
        var inputArgTypes = [];
        m.arguments.forEach(arg => {
            var inputType = buildAsType(arg.type);

            recieve += format(`
    let {name} = decoder.decode<{type}>();`, {
                name: arg.name,
                type: inputType
            })
            inputArgs.push(arg.name);
            inputArgTypes.push(buildDIDType(arg.type));
        })

        let actor_call = "";
        let response = "CALL.respondEmpty();"

        //Compute return types
        if (m.returnType.typeName == 'void') {
            actor_call = format(actor_call_void_template, {
                func_name: m.name,
                params: inputArgs.join(",")
            })
        } else {
            actor_call = format(actor_call_template, {
                func_name: m.name,
                params: inputArgs.join(",")
            })

            response = format(`let encoder = CALL.getRespondEncoder();;
    encoder.write<{type}>(response);
    CALL.sendRespondEncoder(encoder);`, {
                type: buildAsType(m.returnType)
            })
        }

        method_template += format(canister_method_template, {
            func_name: m.name,
            func_type: funcType,
            actor_call: actor_call,
            response: response,
            recieve: recieve,
        });

        //Build DID
        var returnType = buildAsType(m.returnType);

        did_methods_template += format(
            `\t{func_name}: ({input_types}) -> ({return_type}){call_type};\n`, {
            func_name: m.name,
            input_types: inputArgTypes.map(x => toIDLType(x)).join(","),
            return_type: returnType == 'void' ? '' : buildDIDType(m.returnType),
            call_type: getIDLCallType(funcType, returnType)
        }
        )
    }
});

function getIDLCallType(funcType, returnType){
    if(returnType == 'void'){
        return ' oneway'
    }
    if(funcType == 'canister_query'){
        return ' query'
    } 
    return '';
}

function toIDLType(type) {
    switch (type.toLowerCase()) {
        case "string":
            return "text"
        case "u8":
            return "nat8"
        case "u16":
            return "nat16"
        case "u32":
            return "nat32"
        case "u64":
            return "nat64"
        case "i8":
            return "int8"
        case "i16":
            return "int16"
        case "i32":
            return "int32"
        case "i64":
            return "int64"
        case "f32":
            return "float32"
        case "f64":
            return "float64"
    }
    return type;
}

function buildAsType(returnType) {

    //object as list Object[]
    if (returnType.typeKind == 1) {
        return format('{type}[]', {
            type: returnType.base.typeName
        });
    }

    //object with types Object<T>
    if (returnType.typeArguments.length > 0) {
        return format('{type}<{types}>', {
            type: returnType.typeName,
            types: returnType.typeArguments.map(x => x.typeName).join(',')
        });
    }
    return returnType.typeName;
}

function buildDIDType(returnType) {

    //object as list Object[]
    if (returnType.typeKind == 1) {
        return format('vec {type}', {
            type: toIDLType(returnType.base.typeName)
        });
    }

    //object with types Object<T>
    if (returnType.typeArguments.length > 0) {
        return format('vec {type}', {
            type: returnType.typeArguments.map(x => toIDLType((x.typeName))).join(';')
        });
    }
    return toIDLType(returnType.typeName);
}

//TODO: suport Object<Object<Object<T>>>
function getFunctionType(text) {
    if (text.indexOf("@query") != -1) {
        return "canister_query";
    } else if (text.indexOf("@update") != -1) {
        return "canister_update";
    }
    return null;
}


canister_init_template = format(canister_init_template, {
    actor_class_name: actorClass.name
})


var output = format(template, {
    canister_init: canister_init_template,
    canister_methods: method_template,
    actor_class_name: actorClass.name
})

fs.writeFile(outputFile, output, function (err) {
    if (err) return console.log(err);
});


var did_output = format(did_template, {
    did_methods: did_methods_template
});

fs.writeFile(".dfx/local/canisters/ashello/ashello.did", did_output, function (err) {
    if (err) return console.log(err);
});
