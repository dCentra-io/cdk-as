var tsFileStruct = require("ts-file-parser");
var fs = require('fs');
var format = require("string-template");

var inputArgs = process.argv.slice(2);

var inputFile = inputArgs[0];
var outputFile = inputArgs[1];

var decls = fs.readFileSync(inputFile).toString();
var jsonStructure = tsFileStruct.parseStruct(decls, {}, inputFile);

var template = `
// *************************************
// THIS IS GENERATED BY THE ACTOR PARSER
// *************************************
import * as CALL from "./lib/call";
import * as API from "./lib/api";
import * as COUNTER from "./counter";

var actor: COUNTER.{actor_class_name};
{canister_init}
{canister_methods}
`

var canister_init_template = `
export function canister_init(): void {
    var text: string = "Hello DFINITY from AssemblyScript";
    API.print(text);
    actor = new COUNTER.{actor_class_name}();
}
`

var canister_method_template = `
export function {func_type}_{func_name}(): void {
    //recieve inputs
    {recieve}

    //call function
    {actor_call}

    //respond
    {response}
}
`

var actor_call_void_template = `actor.{func_name}({params});`

var actor_call_template = `let response = actor.{func_name}({params});`

//TODO: search for the first class that extends the Actor class
var actorClass = jsonStructure.classes[0];

var method_template = "";

actorClass.methods.forEach(m => {

    var funcType = getFunctionType(m.text);

    let recieve = m.arguments.length == 0 ?
        "CALL.receiveEmpty();" :
        "var decoder = CALL.receiveDecoder();";

    let inputArgs = [];
    m.arguments.forEach(arg => {

        recieve += format(`
    let {name} = decoder.decode<{type}>();`, {
            name: arg.name,
            type: buildReturnType(arg.type)
        })
        inputArgs.push(arg.name);
    })

    let actor_call = "";
    let response = "CALL.respondEmpty();"


    if (m.returnType.typeName == 'void') {
        actor_call = format(actor_call_void_template, {
            func_name: m.name,
            params: inputArgs.join(",")
        })
    } else {
        actor_call = format(actor_call_template, {
            func_name: m.name,
            params: inputArgs.join(",")
        })

        response = format(`let encoder = CALL.respondEncoder();;
    encoder.write<{type}>(response);
    encoder.reply();`, {
            type: buildReturnType(m.returnType)
        })
    }

    method_template += format(canister_method_template, {
        func_name: m.name,
        func_type: funcType,
        actor_call: actor_call,
        response: response,
        recieve: recieve,
    });
});

function buildReturnType(returnType){

    //object as list Object[]
    if(returnType.typeKind == 1){
        return format('{type}[]',{
            type: returnType.base.typeName
        });
    }

    //object with types Object<T>
    if(returnType.typeArguments.length > 0){
        var template_typed = '{type}<{types}>'
        return format('{type}<{types}>',{
            type: returnType.typeName,
            types: returnType.typeArguments.map(x=> x.typeName).join(',')
        });
    }
    return returnType.typeName;
}

//TODO: suport Object<Object<Object<T>>>
function getFunctionType(text) {
    if (text.indexOf("@query") != -1) {
        return "canister_query";
    } else if (text.indexOf("@update") != -1) {
        return "canister_update";
    }
    return "ignore";
}


canister_init_template = format(canister_init_template,{
    actor_class_name: actorClass.name
})


var output = format(template,{
    canister_init: canister_init_template,
    canister_methods: method_template,
    actor_class_name: actorClass.name
})


fs.writeFile(outputFile, output, function (err) {
    if (err) return console.log(err);
});